// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/roderm/example-plugin-system/app/ent/entdb"
	"github.com/roderm/example-plugin-system/app/pkg/graph/v2/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	s := &executableSchema{
		resolvers:             cfg.Resolvers,
		directives:            cfg.Directives,
		complexity:            cfg.Complexity,
		sources:               sources,
		schema:                gqlparser.MustLoadSchema(sources...),
		fieldResolve:          []map[string]func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error){},
		queryResolvers:        []func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){},
		mutationResolvers:     []func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){},
		subscriptionResolvers: []func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error){},
	}
	return s
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Todo() TodoResolver
	User() UserResolver
}

type DirectiveRoot struct {
	GenerateFilter func(ctx context.Context, obj interface{}, next graphql.Resolver, where *string, purchaseBy *string) (res interface{}, err error)
	OneOf          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Mutation struct {
		CreateTodo func(childComplexity int, input entdb.CreateTodoInput) int
		CreateUser func(childComplexity int, input entdb.CreateUserInput) int
		DeleteTodo func(childComplexity int, id int) int
		DeleteUser func(childComplexity int, id int) int
		UpdateTodo func(childComplexity int, id int, input entdb.UpdateTodoInput) int
		UpdateUser func(childComplexity int, id int, input entdb.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Todos func(childComplexity int, filter *entdb.TodoWhereInput, paging *model.Paging) int
		Users func(childComplexity int, filter *entdb.UserWhereInput, paging *model.Paging) int
	}

	Todo struct {
		Desciption func(childComplexity int) int
		Done       func(childComplexity int) int
		ID         func(childComplexity int) int
		User       func(childComplexity int) int
	}

	TodoConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TodoEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		Firstname func(childComplexity int) int
		ID        func(childComplexity int) int
		Lastname  func(childComplexity int) int
		Todos     func(childComplexity int, filter *entdb.TodoWhereInput, paging *model.Paging) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateUser(ctx context.Context, input entdb.CreateUserInput) (*entdb.User, error)
	UpdateUser(ctx context.Context, id int, input entdb.UpdateUserInput) (*entdb.User, error)
	DeleteUser(ctx context.Context, id int) (*entdb.User, error)
	CreateTodo(ctx context.Context, input entdb.CreateTodoInput) (*entdb.Todo, error)
	UpdateTodo(ctx context.Context, id int, input entdb.UpdateTodoInput) (*entdb.Todo, error)
	DeleteTodo(ctx context.Context, id int) (*entdb.Todo, error)
}
type QueryResolver interface {
	Users(ctx context.Context, filter *entdb.UserWhereInput, paging *model.Paging) (*entdb.UserConnection, error)
	Todos(ctx context.Context, filter *entdb.TodoWhereInput, paging *model.Paging) (*entdb.TodoConnection, error)
}
type TodoResolver interface {
	Desciption(ctx context.Context, obj *entdb.Todo) (string, error)
}
type UserResolver interface {
	Todos(ctx context.Context, obj *entdb.User, filter *entdb.TodoWhereInput, paging *model.Paging) (*entdb.TodoConnection, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot

	sources               []*ast.Source
	schema                *ast.Schema
	fieldResolve          []map[string]func(context.Context, graphql.CollectedField, interface{}) (func(*graphql.FieldSet, int) bool, error)
	queryResolvers        []func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error)
	mutationResolvers     []func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error)
	subscriptionResolvers []func(context.Context, graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error)
}

func (e *executableSchema) Schema() *ast.Schema {
	return e.schema
}

func (e *executableSchema) SchemaSources() []*ast.Source {
	return e.sources
}

func (e *executableSchema) Extend(ext graphql.ExecutableSchema) error {
	e.sources = append(e.sources, ext.SchemaSources()...)
	newSchema, err := gqlparser.LoadSchema(e.sources...)
	if err != nil {
		return err
	}
	e.schema = newSchema
	e.fieldResolve = append(e.fieldResolve, ext.GetFieldResolvers()...)
	rootResolvers := ext.GetRootResolvers()
	e.queryResolvers = append(e.queryResolvers, rootResolvers.Query)
	e.mutationResolvers = append(e.mutationResolvers, rootResolvers.Query)
	e.subscriptionResolvers = append(e.subscriptionResolvers, rootResolvers.Query)
	return nil
}

func (e *executableSchema) GetRootResolvers() graphql.SchemaRootResolvers {
	return graphql.SchemaRootResolvers{
		Mutation: e._Mutation_resolve_field,
		Query:    e._Query_resolve_field,
	}
}

func (e *executableSchema) GetFieldResolvers() []map[string]func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
	return []map[string]func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error){map[string]func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error){
		"PageInfo": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.PageInfo)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._PageInfo_resolve_field(ctx, field, obj)
		},
		"Todo": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.Todo)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._Todo_resolve_field(ctx, field, obj)
		},
		"TodoConnection": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.TodoConnection)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._TodoConnection_resolve_field(ctx, field, obj)
		},
		"TodoEdge": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.TodoEdge)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._TodoEdge_resolve_field(ctx, field, obj)
		},
		"User": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.User)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._User_resolve_field(ctx, field, obj)
		},
		"UserConnection": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.UserConnection)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._UserConnection_resolve_field(ctx, field, obj)
		},
		"UserEdge": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*entdb.UserEdge)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e._UserEdge_resolve_field(ctx, field, obj)
		},
		"__Directive": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*introspection.Directive)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e.___Directive_resolve_field(ctx, field, obj)
		},
		"__EnumValue": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*introspection.EnumValue)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e.___EnumValue_resolve_field(ctx, field, obj)
		},
		"__Field": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*introspection.Field)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e.___Field_resolve_field(ctx, field, obj)
		},
		"__InputValue": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*introspection.InputValue)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e.___InputValue_resolve_field(ctx, field, obj)
		},
		"__Schema": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*introspection.Schema)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e.___Schema_resolve_field(ctx, field, obj)
		},
		"__Type": func(ctx context.Context, field graphql.CollectedField, val interface{}) (func(*graphql.FieldSet, int) bool, error) {
			obj, ok := val.(*introspection.Type)
			if !ok {
				return nil, errors.New("invalid type")
			}
			return e.___Type_resolve_field(ctx, field, obj)
		},
	}}
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.createTodo":
		if e.complexity.Mutation.CreateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_createTodo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTodo(childComplexity, args["input"].(entdb.CreateTodoInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(entdb.CreateUserInput)), true

	case "Mutation.deleteTodo":
		if e.complexity.Mutation.DeleteTodo == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTodo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTodo(childComplexity, args["id"].(int)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(int)), true

	case "Mutation.updateTodo":
		if e.complexity.Mutation.UpdateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_updateTodo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTodo(childComplexity, args["id"].(int), args["input"].(entdb.UpdateTodoInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(int), args["input"].(entdb.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.todos":
		if e.complexity.Query.Todos == nil {
			break
		}

		args, err := ec.field_Query_todos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Todos(childComplexity, args["filter"].(*entdb.TodoWhereInput), args["paging"].(*model.Paging)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["filter"].(*entdb.UserWhereInput), args["paging"].(*model.Paging)), true

	case "Todo.desciption":
		if e.complexity.Todo.Desciption == nil {
			break
		}

		return e.complexity.Todo.Desciption(childComplexity), true

	case "Todo.done":
		if e.complexity.Todo.Done == nil {
			break
		}

		return e.complexity.Todo.Done(childComplexity), true

	case "Todo.id":
		if e.complexity.Todo.ID == nil {
			break
		}

		return e.complexity.Todo.ID(childComplexity), true

	case "Todo.user":
		if e.complexity.Todo.User == nil {
			break
		}

		return e.complexity.Todo.User(childComplexity), true

	case "TodoConnection.edges":
		if e.complexity.TodoConnection.Edges == nil {
			break
		}

		return e.complexity.TodoConnection.Edges(childComplexity), true

	case "TodoConnection.pageInfo":
		if e.complexity.TodoConnection.PageInfo == nil {
			break
		}

		return e.complexity.TodoConnection.PageInfo(childComplexity), true

	case "TodoConnection.totalCount":
		if e.complexity.TodoConnection.TotalCount == nil {
			break
		}

		return e.complexity.TodoConnection.TotalCount(childComplexity), true

	case "TodoEdge.cursor":
		if e.complexity.TodoEdge.Cursor == nil {
			break
		}

		return e.complexity.TodoEdge.Cursor(childComplexity), true

	case "TodoEdge.node":
		if e.complexity.TodoEdge.Node == nil {
			break
		}

		return e.complexity.TodoEdge.Node(childComplexity), true

	case "User.firstname":
		if e.complexity.User.Firstname == nil {
			break
		}

		return e.complexity.User.Firstname(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastname":
		if e.complexity.User.Lastname == nil {
			break
		}

		return e.complexity.User.Lastname(childComplexity), true

	case "User.todos":
		if e.complexity.User.Todos == nil {
			break
		}

		args, err := ec.field_User_todos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Todos(childComplexity, args["filter"].(*entdb.TodoWhereInput), args["paging"].(*model.Paging)), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateTodoInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputPaging,
		ec.unmarshalInputTodoWhereInput,
		ec.unmarshalInputUpdateTodoInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := e._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := e._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (e *executableSchema) introspectSchema(ctx context.Context) (*introspection.Schema, error) {
	if graphql.GetOperationContext(ctx).DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(e.schema), nil
}

func (e *executableSchema) introspectType(ctx context.Context, name string) (*introspection.Type, error) {
	if graphql.GetOperationContext(ctx).DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(e.schema, e.schema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "api/ent.graphql", Input: `"""
CreateTodoInput is used for create Todo object.
Input was generated by ent.
"""
input CreateTodoInput {
  description: String!
  done: Time
  userID: ID!
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  firstname: String
  lastname: String
  email: String!
  todoIDs: [ID!]
}
"""
TodoWhereInput is used for filtering Todo objects.
Input was generated by ent.
"""
input TodoWhereInput {
  not: TodoWhereInput
  and: [TodoWhereInput!]
  or: [TodoWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionEqualFold: String
  descriptionContainsFold: String
  """done field predicates"""
  done: Time
  doneNEQ: Time
  doneIn: [Time!]
  doneNotIn: [Time!]
  doneGT: Time
  doneGTE: Time
  doneLT: Time
  doneLTE: Time
  doneIsNil: Boolean
  doneNotNil: Boolean
  """user edge predicates"""
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
}
"""
UpdateTodoInput is used for update Todo object.
Input was generated by ent.
"""
input UpdateTodoInput {
  description: String
  done: Time
  clearDone: Boolean
  userID: ID
  clearUser: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  firstname: String
  clearFirstname: Boolean
  lastname: String
  clearLastname: Boolean
  email: String
  addTodoIDs: [ID!]
  removeTodoIDs: [ID!]
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """firstname field predicates"""
  firstname: String
  firstnameNEQ: String
  firstnameIn: [String!]
  firstnameNotIn: [String!]
  firstnameGT: String
  firstnameGTE: String
  firstnameLT: String
  firstnameLTE: String
  firstnameContains: String
  firstnameHasPrefix: String
  firstnameHasSuffix: String
  firstnameIsNil: Boolean
  firstnameNotNil: Boolean
  firstnameEqualFold: String
  firstnameContainsFold: String
  """lastname field predicates"""
  lastname: String
  lastnameNEQ: String
  lastnameIn: [String!]
  lastnameNotIn: [String!]
  lastnameGT: String
  lastnameGTE: String
  lastnameLT: String
  lastnameLTE: String
  lastnameContains: String
  lastnameHasPrefix: String
  lastnameHasSuffix: String
  lastnameIsNil: Boolean
  lastnameNotNil: Boolean
  lastnameEqualFold: String
  lastnameContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """todos edge predicates"""
  hasTodos: Boolean
  hasTodosWith: [TodoWhereInput!]
}
`, BuiltIn: false},
	{Name: "api/schema.graphql", Input: `type User implements Node {
	id: ID!
	firstname: String
	lastname: String

	todos(filter: TodoWhereInput, paging: Paging): TodoConnection!
}

type UserEdge {
  cursor: Cursor!
  node: User
}

type UserConnection {
  edges: [UserEdge]
  pageInfo: PageInfo
  totalCount: Int
}

type Todo implements Node {
	id: ID!
	desciption: String!
	done: Time
	user: User!
}

type TodoEdge {
  cursor: Cursor!
  node: Todo
}

type TodoConnection {
  edges: [TodoEdge]
  pageInfo: PageInfo
  totalCount: Int
}

type Query {
	users(filter: UserWhereInput, paging: Paging): UserConnection!
	todos(filter: TodoWhereInput, paging: Paging): TodoConnection!
}

type Mutation {
	createUser(input: CreateUserInput!): User!
	updateUser(id: ID!, input: UpdateUserInput!): User!
	deleteUser(id: ID!): User!

	createTodo(input: CreateTodoInput!): Todo!
	updateTodo(id: ID!, input: UpdateTodoInput!): Todo!
	deleteTodo(id: ID!): Todo!
}
`, BuiltIn: false},
	{Name: "api/types.graphql", Input: `directive @goField(
  forceResolver: Boolean
  name: String
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @goModel(
  model: String
  models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @generateFilter(where: String, purchaseBy: String) on OBJECT | UNION
directive @oneOf on INPUT_OBJECT # should this be INPUT_OBJECT?
"""
https://www.graphql-scalars.dev/docs/scalars/uuid
"""
scalar UUID
"""
https://www.graphql-scalars.dev/docs/scalars/time
"""
scalar Time

"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node
  @goModel(
    model: "github.com/roderm/example-plugin-system/app/ent/entdb.Noder"
  ) {
  """
  The id of the object.
  """
  id: ID!
}

"""
Paging Input as described:
https://graphql.org/learn/pagination/
"""
input Paging {
  after: Cursor
  first: Int
  before: Cursor
  last: Int
}

"""
https://relay.dev/graphql/connections.htm#sec-Connection-Types.Fields.PageInfo
"""
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}
`, BuiltIn: false},
}

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (e *executableSchema) dir_generateFilter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["where"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = e.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["purchaseBy"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("purchaseBy"))
		arg1, err = e.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["purchaseBy"] = arg1
	return args, nil
}

func (e *executableSchema) field_Mutation_createTodo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entdb.CreateTodoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = e.unmarshalNCreateTodoInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCreateTodoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (e *executableSchema) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 entdb.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = e.unmarshalNCreateUserInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (e *executableSchema) field_Mutation_deleteTodo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = e.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (e *executableSchema) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = e.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (e *executableSchema) field_Mutation_updateTodo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = e.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 entdb.UpdateTodoInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = e.unmarshalNUpdateTodoInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUpdateTodoInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (e *executableSchema) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = e.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 entdb.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = e.unmarshalNUpdateUserInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (e *executableSchema) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = e.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (e *executableSchema) field_Query_todos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entdb.TodoWhereInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = e.unmarshalOTodoWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.Paging
	if tmp, ok := rawArgs["paging"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("paging"))
		arg1, err = e.unmarshalOPaging2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋpkgᚋgraphᚋv2ᚋmodelᚐPaging(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paging"] = arg1
	return args, nil
}

func (e *executableSchema) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entdb.UserWhereInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = e.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.Paging
	if tmp, ok := rawArgs["paging"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("paging"))
		arg1, err = e.unmarshalOPaging2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋpkgᚋgraphᚋv2ᚋmodelᚐPaging(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paging"] = arg1
	return args, nil
}

func (e *executableSchema) field_User_todos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entdb.TodoWhereInput
	if tmp, ok := rawArgs["filter"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = e.unmarshalOTodoWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *model.Paging
	if tmp, ok := rawArgs["paging"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("paging"))
		arg1, err = e.unmarshalOPaging2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋpkgᚋgraphᚋv2ᚋmodelᚐPaging(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["paging"] = arg1
	return args, nil
}

func (e *executableSchema) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = e.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (e *executableSchema) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = e.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (e *executableSchema) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Mutation_createUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(entdb.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.User)
	fc.Result = res
	return e.marshalNUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firstname":
				return ec.fieldContext_User_firstname(ctx, field)
			case "lastname":
				return ec.fieldContext_User_lastname(ctx, field)
			case "todos":
				return ec.fieldContext_User_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Mutation_updateUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(int), fc.Args["input"].(entdb.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.User)
	fc.Result = res
	return e.marshalNUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firstname":
				return ec.fieldContext_User_firstname(ctx, field)
			case "lastname":
				return ec.fieldContext_User_lastname(ctx, field)
			case "todos":
				return ec.fieldContext_User_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Mutation_deleteUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Mutation().DeleteUser(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.User)
	fc.Result = res
	return e.marshalNUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firstname":
				return ec.fieldContext_User_firstname(ctx, field)
			case "lastname":
				return ec.fieldContext_User_lastname(ctx, field)
			case "todos":
				return ec.fieldContext_User_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Mutation_createTodo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Mutation_createTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Mutation_createTodo_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Mutation().CreateTodo(rctx, fc.Args["input"].(entdb.CreateTodoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.Todo)
	fc.Result = res
	return e.marshalNTodo2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "desciption":
				return ec.fieldContext_Todo_desciption(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTodo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Mutation_updateTodo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Mutation_updateTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Mutation_updateTodo_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Mutation().UpdateTodo(rctx, fc.Args["id"].(int), fc.Args["input"].(entdb.UpdateTodoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.Todo)
	fc.Result = res
	return e.marshalNTodo2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "desciption":
				return ec.fieldContext_Todo_desciption(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTodo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Mutation_deleteTodo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Mutation_deleteTodo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Mutation_deleteTodo_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Mutation().DeleteTodo(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.Todo)
	fc.Result = res
	return e.marshalNTodo2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTodo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "desciption":
				return ec.fieldContext_Todo_desciption(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTodo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entdb.PageInfo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return e.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entdb.PageInfo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return e.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entdb.PageInfo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entdb.Cursor)
	fc.Result = res
	return e.marshalOCursor2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entdb.PageInfo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entdb.Cursor)
	fc.Result = res
	return e.marshalOCursor2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Query_users_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Query().Users(rctx, fc.Args["filter"].(*entdb.UserWhereInput), fc.Args["paging"].(*model.Paging))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.UserConnection)
	fc.Result = res
	return e.marshalNUserConnection2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_UserConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_UserConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_UserConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Query_todos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Query_todos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Query_todos_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Query().Todos(rctx, fc.Args["filter"].(*entdb.TodoWhereInput), fc.Args["paging"].(*model.Paging))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.TodoConnection)
	fc.Result = res
	return e.marshalNTodoConnection2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_todos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TodoConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TodoConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TodoConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TodoConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_todos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.introspectType(ctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.introspectSchema(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return e.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _Todo_id(ctx context.Context, field graphql.CollectedField, obj *entdb.Todo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Todo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return e.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _Todo_desciption(ctx context.Context, field graphql.CollectedField, obj *entdb.Todo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Todo_desciption(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.Todo().Desciption(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_desciption(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _Todo_done(ctx context.Context, field graphql.CollectedField, obj *entdb.Todo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Todo_done(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Done, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return e.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_done(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _Todo_user(ctx context.Context, field graphql.CollectedField, obj *entdb.Todo) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_Todo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.User)
	fc.Result = res
	return e.marshalNUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Todo_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Todo",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firstname":
				return ec.fieldContext_User_firstname(ctx, field)
			case "lastname":
				return ec.fieldContext_User_lastname(ctx, field)
			case "todos":
				return ec.fieldContext_User_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _TodoConnection_edges(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoConnection) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_TodoConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entdb.TodoEdge)
	fc.Result = res
	return e.marshalOTodoEdge2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_TodoEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_TodoEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TodoEdge", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _TodoConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoConnection) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_TodoConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(entdb.PageInfo)
	fc.Result = res
	return e.marshalOPageInfo2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _TodoConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoConnection) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_TodoConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return e.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _TodoEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoEdge) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_TodoEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entdb.Cursor)
	fc.Result = res
	return e.marshalNCursor2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _TodoEdge_node(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoEdge) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_TodoEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entdb.Todo)
	fc.Result = res
	return e.marshalOTodo2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TodoEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TodoEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Todo_id(ctx, field)
			case "desciption":
				return ec.fieldContext_Todo_desciption(ctx, field)
			case "done":
				return ec.fieldContext_Todo_done(ctx, field)
			case "user":
				return ec.fieldContext_Todo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Todo", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _User_id(ctx context.Context, field graphql.CollectedField, obj *entdb.User) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return e.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _User_firstname(ctx context.Context, field graphql.CollectedField, obj *entdb.User) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_User_firstname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Firstname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_firstname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _User_lastname(ctx context.Context, field graphql.CollectedField, obj *entdb.User) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_User_lastname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lastname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_lastname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _User_todos(ctx context.Context, field graphql.CollectedField, obj *entdb.User) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_User_todos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field_User_todos_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return e.resolvers.User().Todos(rctx, obj, fc.Args["filter"].(*entdb.TodoWhereInput), fc.Args["paging"].(*model.Paging))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*entdb.TodoConnection)
	fc.Result = res
	return e.marshalNTodoConnection2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_todos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TodoConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TodoConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TodoConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TodoConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_todos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) _UserConnection_edges(ctx context.Context, field graphql.CollectedField, obj *entdb.UserConnection) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_UserConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*entdb.UserEdge)
	fc.Result = res
	return e.marshalOUserEdge2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_UserEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_UserEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserEdge", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *entdb.UserConnection) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_UserConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(entdb.PageInfo)
	fc.Result = res
	return e.marshalOPageInfo2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) _UserConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *entdb.UserConnection) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_UserConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return e.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _UserEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *entdb.UserEdge) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_UserEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entdb.Cursor)
	fc.Result = res
	return e.marshalNCursor2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) _UserEdge_node(ctx context.Context, field graphql.CollectedField, obj *entdb.UserEdge) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext_UserEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entdb.User)
	fc.Result = res
	return e.marshalOUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "firstname":
				return ec.fieldContext_User_firstname(ctx, field)
			case "lastname":
				return ec.fieldContext_User_lastname(ctx, field)
			case "todos":
				return ec.fieldContext_User_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return e.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return e.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return e.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return e.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return e.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return e.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return e.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return e.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return e.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return e.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return e.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return e.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(graphql.GetOperationContext(ctx).Variables)
	args, err := e.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return e.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (e *executableSchema) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return e.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return e.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (e *executableSchema) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := graphql.GetOperationContext(ctx).ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return e.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (e *executableSchema) unmarshalInputCreateTodoInput(ctx context.Context, obj interface{}) (entdb.CreateTodoInput, error) {
	var it entdb.CreateTodoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "description":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = e.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "done":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("done"))
			it.Done, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "userID":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			it.UserID, err = e.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (entdb.CreateUserInput, error) {
	var it entdb.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "firstname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstname"))
			it.Firstname, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastname"))
			it.Lastname, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = e.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "todoIDs":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("todoIDs"))
			it.TodoIDs, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) unmarshalInputPaging(ctx context.Context, obj interface{}) (model.Paging, error) {
	var it model.Paging
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "after":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = e.unmarshalOCursor2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx, v)
			if err != nil {
				return it, err
			}
		case "first":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			it.First, err = e.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "before":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = e.unmarshalOCursor2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx, v)
			if err != nil {
				return it, err
			}
		case "last":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			it.Last, err = e.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) unmarshalInputTodoWhereInput(ctx context.Context, obj interface{}) (entdb.TodoWhereInput, error) {
	var it entdb.TodoWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = e.unmarshalOTodoWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = e.unmarshalOTodoWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = e.unmarshalOTodoWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			it.DescriptionNEQ, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			it.DescriptionIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			it.DescriptionNotIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			it.DescriptionGT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			it.DescriptionGTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			it.DescriptionLT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			it.DescriptionLTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContains":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			it.DescriptionContains, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasPrefix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			it.DescriptionHasPrefix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionHasSuffix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			it.DescriptionHasSuffix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEqualFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			it.DescriptionEqualFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionContainsFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			it.DescriptionContainsFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "done":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("done"))
			it.Done, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneNEQ"))
			it.DoneNEQ, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneIn"))
			it.DoneIn, err = e.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneNotIn"))
			it.DoneNotIn, err = e.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneGT"))
			it.DoneGT, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneGTE"))
			it.DoneGTE, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneLT"))
			it.DoneLT, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneLTE"))
			it.DoneLTE, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneIsNil":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneIsNil"))
			it.DoneIsNil, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "doneNotNil":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("doneNotNil"))
			it.DoneNotNil, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasUser":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			it.HasUser, err = e.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasUserWith":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			it.HasUserWith, err = e.unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) unmarshalInputUpdateTodoInput(ctx context.Context, obj interface{}) (entdb.UpdateTodoInput, error) {
	var it entdb.UpdateTodoInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "description":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "done":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("done"))
			it.Done, err = e.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearDone":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDone"))
			it.ClearDone, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "userID":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			it.UserID, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearUser":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("clearUser"))
			it.ClearUser, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (entdb.UpdateUserInput, error) {
	var it entdb.UpdateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "firstname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstname"))
			it.Firstname, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearFirstname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("clearFirstname"))
			it.ClearFirstname, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastname"))
			it.Lastname, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "clearLastname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLastname"))
			it.ClearLastname, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "addTodoIDs":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("addTodoIDs"))
			it.AddTodoIDs, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "removeTodoIDs":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("removeTodoIDs"))
			it.RemoveTodoIDs, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (e *executableSchema) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (entdb.UserWhereInput, error) {
	var it entdb.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "not":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			it.Not, err = e.unmarshalOUserWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "and":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			it.And, err = e.unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "or":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			it.Or, err = e.unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "id":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			it.IDNEQ, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			it.IDIn, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			it.IDNotIn, err = e.unmarshalOID2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			it.IDGT, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			it.IDGTE, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			it.IDLT, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "idLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			it.IDLTE, err = e.unmarshalOID2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstname"))
			it.Firstname, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameNEQ"))
			it.FirstnameNEQ, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameIn"))
			it.FirstnameIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameNotIn"))
			it.FirstnameNotIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameGT"))
			it.FirstnameGT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameGTE"))
			it.FirstnameGTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameLT"))
			it.FirstnameLT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameLTE"))
			it.FirstnameLTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameContains":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameContains"))
			it.FirstnameContains, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameHasPrefix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameHasPrefix"))
			it.FirstnameHasPrefix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameHasSuffix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameHasSuffix"))
			it.FirstnameHasSuffix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameIsNil":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameIsNil"))
			it.FirstnameIsNil, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameNotNil":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameNotNil"))
			it.FirstnameNotNil, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameEqualFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameEqualFold"))
			it.FirstnameEqualFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "firstnameContainsFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("firstnameContainsFold"))
			it.FirstnameContainsFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastname":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastname"))
			it.Lastname, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameNEQ"))
			it.LastnameNEQ, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameIn"))
			it.LastnameIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameNotIn"))
			it.LastnameNotIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameGT"))
			it.LastnameGT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameGTE"))
			it.LastnameGTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameLT"))
			it.LastnameLT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameLTE"))
			it.LastnameLTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameContains":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameContains"))
			it.LastnameContains, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameHasPrefix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameHasPrefix"))
			it.LastnameHasPrefix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameHasSuffix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameHasSuffix"))
			it.LastnameHasSuffix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameIsNil":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameIsNil"))
			it.LastnameIsNil, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameNotNil":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameNotNil"))
			it.LastnameNotNil, err = e.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameEqualFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameEqualFold"))
			it.LastnameEqualFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastnameContainsFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("lastnameContainsFold"))
			it.LastnameContainsFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailNEQ":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			it.EmailNEQ, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			it.EmailIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailNotIn":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			it.EmailNotIn, err = e.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailGT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			it.EmailGT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailGTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			it.EmailGTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailLT":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			it.EmailLT, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailLTE":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			it.EmailLTE, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailContains":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			it.EmailContains, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailHasPrefix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			it.EmailHasPrefix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailHasSuffix":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			it.EmailHasSuffix, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailEqualFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			it.EmailEqualFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "emailContainsFold":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			it.EmailContainsFold, err = e.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTodos":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTodos"))
			it.HasTodos, err = e.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "hasTodosWith":
			var err error

			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTodosWith"))
			it.HasTodosWith, err = e.unmarshalOTodoWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (e *executableSchema) _Node(ctx context.Context, sel ast.SelectionSet, obj entdb.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *entdb.User:
		if obj == nil {
			return graphql.Null
		}
		return e._User(ctx, sel, obj)
	case *entdb.Todo:
		if obj == nil {
			return graphql.Null
		}
		return e._Todo(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var mutationImplementors = []string{"Mutation"}

func (e *executableSchema) _Mutation_resolve_field(ctx context.Context, field graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error) {
	innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
		Object: field.Name,
		Field:  field,
	})

	// var invalids uint32
	switch field.Name {
	case "createUser":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Mutation_createUser(ctx, field)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			return out.Values[i] != graphql.Null
		}, nil
	case "updateUser":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Mutation_updateUser(ctx, field)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			return out.Values[i] != graphql.Null
		}, nil
	case "deleteUser":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Mutation_deleteUser(ctx, field)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			return out.Values[i] != graphql.Null
		}, nil
	case "createTodo":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Mutation_createTodo(ctx, field)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			return out.Values[i] != graphql.Null
		}, nil
	case "updateTodo":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Mutation_updateTodo(ctx, field)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			return out.Values[i] != graphql.Null
		}, nil
	case "deleteTodo":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Mutation_deleteTodo(ctx, field)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = graphql.GetOperationContext(ctx).RootResolverMiddleware(innerCtx, innerFunc)
			return out.Values[i] != graphql.Null
		}, nil
	default:
		for _, x := range e.mutationResolvers {
			if res, err := x(ctx, field); err != nil {
				return res, err
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("Mutation")
			continue
		}
		resolve, err := e._Mutation_resolve_field(ctx, field)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (e *executableSchema) _PageInfo_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.PageInfo) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "hasNextPage":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._PageInfo_hasNextPage(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "hasPreviousPage":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._PageInfo_hasPreviousPage(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "startCursor":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._PageInfo_startCursor(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "endCursor":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._PageInfo_endCursor(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["PageInfo"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entdb.PageInfo) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("PageInfo")
			continue
		}
		resolve, err := e._PageInfo_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (e *executableSchema) _Query_resolve_field(ctx context.Context, field graphql.CollectedField) (func(*graphql.FieldSet, int) bool, error) {
	innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
		Object: field.Name,
		Field:  field,
	})

	// var invalids uint32
	switch field.Name {
	case "users":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._Query_users(ctx, field)
			// if res == graphql.Null {
			// 		atomic.AddUint32(&invalids, 1)
			// }
			return res
		}
		rrm := func(ctx context.Context) graphql.Marshaler {
			return graphql.GetOperationContext(ctx).RootResolverMiddleware(ctx, innerFunc)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
			return true
		}, nil
	case "todos":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._Query_todos(ctx, field)
			// if res == graphql.Null {
			// 		atomic.AddUint32(&invalids, 1)
			// }
			return res
		}
		rrm := func(ctx context.Context) graphql.Marshaler {
			return graphql.GetOperationContext(ctx).RootResolverMiddleware(ctx, innerFunc)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
			return true
		}, nil
	case "__type":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._Query___type(ctx, field)
			return res
		}
		rrm := func(ctx context.Context) graphql.Marshaler {
			return graphql.GetOperationContext(ctx).RootResolverMiddleware(ctx, innerFunc)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
			return true
		}, nil
	case "__schema":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._Query___schema(ctx, field)
			return res
		}
		rrm := func(ctx context.Context) graphql.Marshaler {
			return graphql.GetOperationContext(ctx).RootResolverMiddleware(ctx, innerFunc)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
			return true
		}, nil
	default:
		for _, x := range e.queryResolvers {
			if res, err := x(ctx, field); err != nil {
				return res, err
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("Query")
			continue
		}
		resolve, err := e._Query_resolve_field(ctx, field)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var todoImplementors = []string{"Todo", "Node"}

func (e *executableSchema) _Todo_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.Todo) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "id":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Todo_id(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "desciption":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._Todo_desciption(ctx, field, obj)
			// if res == graphql.Null {
			// 		atomic.AddUint32(&invalids, 1)
			// }
			return res
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
			return true
		}, nil
	case "done":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._Todo_done(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "user":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._Todo_user(ctx, field, obj)
			// if res == graphql.Null {
			// 		atomic.AddUint32(&invalids, 1)
			// }
			return res
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["Todo"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _Todo(ctx context.Context, sel ast.SelectionSet, obj *entdb.Todo) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, todoImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("Todo")
			continue
		}
		resolve, err := e._Todo_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var todoConnectionImplementors = []string{"TodoConnection"}

func (e *executableSchema) _TodoConnection_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoConnection) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "edges":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._TodoConnection_edges(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "pageInfo":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._TodoConnection_pageInfo(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "totalCount":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._TodoConnection_totalCount(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["TodoConnection"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _TodoConnection(ctx context.Context, sel ast.SelectionSet, obj *entdb.TodoConnection) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, todoConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("TodoConnection")
			continue
		}
		resolve, err := e._TodoConnection_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var todoEdgeImplementors = []string{"TodoEdge"}

func (e *executableSchema) _TodoEdge_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.TodoEdge) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "cursor":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._TodoEdge_cursor(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "node":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._TodoEdge_node(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["TodoEdge"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _TodoEdge(ctx context.Context, sel ast.SelectionSet, obj *entdb.TodoEdge) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, todoEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("TodoEdge")
			continue
		}
		resolve, err := e._TodoEdge_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User", "Node"}

func (e *executableSchema) _User_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.User) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "id":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._User_id(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "firstname":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._User_firstname(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "lastname":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._User_lastname(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "todos":
		field := field

		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
				}
			}()
			res = e._User_todos(ctx, field, obj)
			// if res == graphql.Null {
			// 		atomic.AddUint32(&invalids, 1)
			// }
			return res
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)
			})
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["User"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _User(ctx context.Context, sel ast.SelectionSet, obj *entdb.User) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("User")
			continue
		}
		resolve, err := e._User_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userConnectionImplementors = []string{"UserConnection"}

func (e *executableSchema) _UserConnection_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.UserConnection) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "edges":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._UserConnection_edges(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "pageInfo":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._UserConnection_pageInfo(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "totalCount":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._UserConnection_totalCount(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["UserConnection"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _UserConnection(ctx context.Context, sel ast.SelectionSet, obj *entdb.UserConnection) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, userConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("UserConnection")
			continue
		}
		resolve, err := e._UserConnection_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userEdgeImplementors = []string{"UserEdge"}

func (e *executableSchema) _UserEdge_resolve_field(ctx context.Context, field graphql.CollectedField, obj *entdb.UserEdge) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "cursor":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._UserEdge_cursor(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "node":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e._UserEdge_node(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["UserEdge"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) _UserEdge(ctx context.Context, sel ast.SelectionSet, obj *entdb.UserEdge) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, userEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("UserEdge")
			continue
		}
		resolve, err := e._UserEdge_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (e *executableSchema) ___Directive_resolve_field(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "name":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Directive_name(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "description":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Directive_description(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "locations":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Directive_locations(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "args":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Directive_args(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "isRepeatable":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Directive_isRepeatable(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["__Directive"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("__Directive")
			continue
		}
		resolve, err := e.___Directive_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (e *executableSchema) ___EnumValue_resolve_field(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "name":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___EnumValue_name(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "description":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___EnumValue_description(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "isDeprecated":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___EnumValue_isDeprecated(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "deprecationReason":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___EnumValue_deprecationReason(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["__EnumValue"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("__EnumValue")
			continue
		}
		resolve, err := e.___EnumValue_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (e *executableSchema) ___Field_resolve_field(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "name":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Field_name(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "description":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Field_description(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "args":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Field_args(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "type":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Field_type(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "isDeprecated":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Field_isDeprecated(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "deprecationReason":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Field_deprecationReason(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["__Field"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("__Field")
			continue
		}
		resolve, err := e.___Field_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (e *executableSchema) ___InputValue_resolve_field(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "name":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___InputValue_name(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "description":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___InputValue_description(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "type":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___InputValue_type(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "defaultValue":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___InputValue_defaultValue(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["__InputValue"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("__InputValue")
			continue
		}
		resolve, err := e.___InputValue_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (e *executableSchema) ___Schema_resolve_field(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "description":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Schema_description(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "types":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Schema_types(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "queryType":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Schema_queryType(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "mutationType":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Schema_mutationType(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "subscriptionType":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Schema_subscriptionType(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "directives":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Schema_directives(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["__Schema"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("__Schema")
			continue
		}
		resolve, err := e.___Schema_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (e *executableSchema) ___Type_resolve_field(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (func(*graphql.FieldSet, int) bool, error) {
	// var invalids uint32
	switch field.Name {
	case "kind":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_kind(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return out.Values[i] != graphql.Null
		}, nil
	case "name":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_name(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "description":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_description(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "fields":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_fields(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "interfaces":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_interfaces(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "possibleTypes":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_possibleTypes(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "enumValues":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_enumValues(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "inputFields":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_inputFields(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "ofType":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_ofType(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	case "specifiedByURL":
		innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
			return e.___Type_specifiedByURL(ctx, field, obj)
		}
		return func(out *graphql.FieldSet, i int) bool {
			out.Values[i] = innerFunc(ctx)
			return true
		}, nil
	default:
		for _, x := range e.fieldResolve {
			if r, ok := x["__Type"]; ok {
				return r(ctx, field, obj)
			}
		}
	}
	return nil, errors.New("unknown field " + strconv.Quote(field.Name))
}
func (e *executableSchema) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	ec := executionContext{graphql.GetOperationContext(ctx), e}
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		if field.Name == "__typename" {
			out.Values[i] = graphql.MarshalString("__Type")
			continue
		}
		resolve, err := e.___Type_resolve_field(ctx, field, obj)
		if err != nil {
			panic(err)
		}
		ok := resolve(out, i)
		if !ok {
			invalids++
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (e *executableSchema) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (e *executableSchema) unmarshalNCreateTodoInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCreateTodoInput(ctx context.Context, v interface{}) (entdb.CreateTodoInput, error) {
	res, err := e.unmarshalInputCreateTodoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) unmarshalNCreateUserInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCreateUserInput(ctx context.Context, v interface{}) (entdb.CreateUserInput, error) {
	res, err := e.unmarshalInputCreateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) unmarshalNCursor2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx context.Context, v interface{}) (entdb.Cursor, error) {
	var res entdb.Cursor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalNCursor2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx context.Context, sel ast.SelectionSet, v entdb.Cursor) graphql.Marshaler {
	return v
}

func (e *executableSchema) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (e *executableSchema) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (e *executableSchema) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (e *executableSchema) marshalNTodo2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx context.Context, sel ast.SelectionSet, v entdb.Todo) graphql.Marshaler {
	return e._Todo(ctx, sel, &v)
}

func (e *executableSchema) marshalNTodo2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx context.Context, sel ast.SelectionSet, v *entdb.Todo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return e._Todo(ctx, sel, v)
}

func (e *executableSchema) marshalNTodoConnection2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoConnection(ctx context.Context, sel ast.SelectionSet, v entdb.TodoConnection) graphql.Marshaler {
	return e._TodoConnection(ctx, sel, &v)
}

func (e *executableSchema) marshalNTodoConnection2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoConnection(ctx context.Context, sel ast.SelectionSet, v *entdb.TodoConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return e._TodoConnection(ctx, sel, v)
}

func (e *executableSchema) unmarshalNTodoWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInput(ctx context.Context, v interface{}) (*entdb.TodoWhereInput, error) {
	res, err := e.unmarshalInputTodoWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) unmarshalNUpdateTodoInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUpdateTodoInput(ctx context.Context, v interface{}) (entdb.UpdateTodoInput, error) {
	res, err := e.unmarshalInputUpdateTodoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) unmarshalNUpdateUserInput2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUpdateUserInput(ctx context.Context, v interface{}) (entdb.UpdateUserInput, error) {
	res, err := e.unmarshalInputUpdateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalNUser2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx context.Context, sel ast.SelectionSet, v entdb.User) graphql.Marshaler {
	return e._User(ctx, sel, &v)
}

func (e *executableSchema) marshalNUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx context.Context, sel ast.SelectionSet, v *entdb.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return e._User(ctx, sel, v)
}

func (e *executableSchema) marshalNUserConnection2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserConnection(ctx context.Context, sel ast.SelectionSet, v entdb.UserConnection) graphql.Marshaler {
	return e._UserConnection(ctx, sel, &v)
}

func (e *executableSchema) marshalNUserConnection2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserConnection(ctx context.Context, sel ast.SelectionSet, v *entdb.UserConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return e._UserConnection(ctx, sel, v)
}

func (e *executableSchema) unmarshalNUserWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInput(ctx context.Context, v interface{}) (*entdb.UserWhereInput, error) {
	res, err := e.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return e.___Directive(ctx, sel, &v)
}

func (e *executableSchema) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (e *executableSchema) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = e.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (e *executableSchema) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return e.___EnumValue(ctx, sel, &v)
}

func (e *executableSchema) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return e.___Field(ctx, sel, &v)
}

func (e *executableSchema) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return e.___InputValue(ctx, sel, &v)
}

func (e *executableSchema) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return e.___Type(ctx, sel, &v)
}

func (e *executableSchema) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return e.___Type(ctx, sel, v)
}

func (e *executableSchema) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.GetOperationContext(ctx).Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (e *executableSchema) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (e *executableSchema) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (e *executableSchema) unmarshalOCursor2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx context.Context, v interface{}) (*entdb.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entdb.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOCursor2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐCursor(ctx context.Context, sel ast.SelectionSet, v *entdb.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (e *executableSchema) unmarshalOID2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = e.unmarshalNID2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (e *executableSchema) marshalOID2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = e.marshalNID2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) unmarshalOID2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOID2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (e *executableSchema) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (e *executableSchema) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (e *executableSchema) marshalOPageInfo2githubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v entdb.PageInfo) graphql.Marshaler {
	return e._PageInfo(ctx, sel, &v)
}

func (e *executableSchema) unmarshalOPaging2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋpkgᚋgraphᚋv2ᚋmodelᚐPaging(ctx context.Context, v interface{}) (*model.Paging, error) {
	if v == nil {
		return nil, nil
	}
	res, err := e.unmarshalInputPaging(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (e *executableSchema) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = e.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (e *executableSchema) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = e.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (e *executableSchema) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (e *executableSchema) unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = e.unmarshalNTime2timeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (e *executableSchema) marshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = e.marshalNTime2timeᚐTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (e *executableSchema) marshalOTodo2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodo(ctx context.Context, sel ast.SelectionSet, v *entdb.Todo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return e._Todo(ctx, sel, v)
}

func (e *executableSchema) marshalOTodoEdge2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoEdge(ctx context.Context, sel ast.SelectionSet, v []*entdb.TodoEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalOTodoEdge2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (e *executableSchema) marshalOTodoEdge2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoEdge(ctx context.Context, sel ast.SelectionSet, v *entdb.TodoEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return e._TodoEdge(ctx, sel, v)
}

func (e *executableSchema) unmarshalOTodoWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInputᚄ(ctx context.Context, v interface{}) ([]*entdb.TodoWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entdb.TodoWhereInput, len(vSlice))
	for i := range vSlice {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = e.unmarshalNTodoWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (e *executableSchema) unmarshalOTodoWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐTodoWhereInput(ctx context.Context, v interface{}) (*entdb.TodoWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := e.unmarshalInputTodoWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalOUser2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUser(ctx context.Context, sel ast.SelectionSet, v *entdb.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return e._User(ctx, sel, v)
}

func (e *executableSchema) marshalOUserEdge2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v []*entdb.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalOUserEdge2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (e *executableSchema) marshalOUserEdge2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserEdge(ctx context.Context, sel ast.SelectionSet, v *entdb.UserEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return e._UserEdge(ctx, sel, v)
}

func (e *executableSchema) unmarshalOUserWhereInput2ᚕᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInputᚄ(ctx context.Context, v interface{}) ([]*entdb.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*entdb.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx = graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = e.unmarshalNUserWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (e *executableSchema) unmarshalOUserWhereInput2ᚖgithubᚗcomᚋrodermᚋexampleᚑpluginᚑsystemᚋappᚋentᚋentdbᚐUserWhereInput(ctx context.Context, v interface{}) (*entdb.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := e.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (e *executableSchema) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return e.___Schema(ctx, sel, v)
}

func (e *executableSchema) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx = graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					oc := graphql.GetOperationContext(ctx)
					oc.Error(ctx, oc.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = e.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (e *executableSchema) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return e.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
