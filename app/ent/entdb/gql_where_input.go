// Code generated by entc, DO NOT EDIT.

package entdb

import (
	"fmt"
	"time"

	"github.com/roderm/example-plugin-system/app/ent/entdb/predicate"
	"github.com/roderm/example-plugin-system/app/ent/entdb/todo"
	"github.com/roderm/example-plugin-system/app/ent/entdb/user"
)

// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Predicates []predicate.Todo  `json:"-"`
	Not        *TodoWhereInput   `json:"not,omitempty"`
	Or         []*TodoWhereInput `json:"or,omitempty"`
	And        []*TodoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "done" field predicates.
	Done       *time.Time  `json:"done,omitempty"`
	DoneNEQ    *time.Time  `json:"doneNEQ,omitempty"`
	DoneIn     []time.Time `json:"doneIn,omitempty"`
	DoneNotIn  []time.Time `json:"doneNotIn,omitempty"`
	DoneGT     *time.Time  `json:"doneGT,omitempty"`
	DoneGTE    *time.Time  `json:"doneGTE,omitempty"`
	DoneLT     *time.Time  `json:"doneLT,omitempty"`
	DoneLTE    *time.Time  `json:"doneLTE,omitempty"`
	DoneIsNil  bool        `json:"doneIsNil,omitempty"`
	DoneNotNil bool        `json:"doneNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TodoWhereInput) AddPredicates(predicates ...predicate.Todo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TodoWhereInput filter on the TodoQuery builder.
func (i *TodoWhereInput) Filter(q *TodoQuery) (*TodoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering todos.
// An error is returned if the input is empty or invalid.
func (i *TodoWhereInput) P() (predicate.Todo, error) {
	var predicates []predicate.Todo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, todo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Todo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, todo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Todo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, todo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, todo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, todo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, todo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, todo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, todo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, todo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, todo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, todo.IDLTE(*i.IDLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, todo.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, todo.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, todo.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, todo.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, todo.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, todo.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, todo.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, todo.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, todo.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, todo.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, todo.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, todo.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, todo.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Done != nil {
		predicates = append(predicates, todo.DoneEQ(*i.Done))
	}
	if i.DoneNEQ != nil {
		predicates = append(predicates, todo.DoneNEQ(*i.DoneNEQ))
	}
	if len(i.DoneIn) > 0 {
		predicates = append(predicates, todo.DoneIn(i.DoneIn...))
	}
	if len(i.DoneNotIn) > 0 {
		predicates = append(predicates, todo.DoneNotIn(i.DoneNotIn...))
	}
	if i.DoneGT != nil {
		predicates = append(predicates, todo.DoneGT(*i.DoneGT))
	}
	if i.DoneGTE != nil {
		predicates = append(predicates, todo.DoneGTE(*i.DoneGTE))
	}
	if i.DoneLT != nil {
		predicates = append(predicates, todo.DoneLT(*i.DoneLT))
	}
	if i.DoneLTE != nil {
		predicates = append(predicates, todo.DoneLTE(*i.DoneLTE))
	}
	if i.DoneIsNil {
		predicates = append(predicates, todo.DoneIsNil())
	}
	if i.DoneNotNil {
		predicates = append(predicates, todo.DoneNotNil())
	}

	if i.HasUser != nil {
		p := todo.HasUser()
		if !*i.HasUser {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate TodoWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return todo.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "firstname" field predicates.
	Firstname             *string  `json:"firstname,omitempty"`
	FirstnameNEQ          *string  `json:"firstnameNEQ,omitempty"`
	FirstnameIn           []string `json:"firstnameIn,omitempty"`
	FirstnameNotIn        []string `json:"firstnameNotIn,omitempty"`
	FirstnameGT           *string  `json:"firstnameGT,omitempty"`
	FirstnameGTE          *string  `json:"firstnameGTE,omitempty"`
	FirstnameLT           *string  `json:"firstnameLT,omitempty"`
	FirstnameLTE          *string  `json:"firstnameLTE,omitempty"`
	FirstnameContains     *string  `json:"firstnameContains,omitempty"`
	FirstnameHasPrefix    *string  `json:"firstnameHasPrefix,omitempty"`
	FirstnameHasSuffix    *string  `json:"firstnameHasSuffix,omitempty"`
	FirstnameIsNil        bool     `json:"firstnameIsNil,omitempty"`
	FirstnameNotNil       bool     `json:"firstnameNotNil,omitempty"`
	FirstnameEqualFold    *string  `json:"firstnameEqualFold,omitempty"`
	FirstnameContainsFold *string  `json:"firstnameContainsFold,omitempty"`

	// "lastname" field predicates.
	Lastname             *string  `json:"lastname,omitempty"`
	LastnameNEQ          *string  `json:"lastnameNEQ,omitempty"`
	LastnameIn           []string `json:"lastnameIn,omitempty"`
	LastnameNotIn        []string `json:"lastnameNotIn,omitempty"`
	LastnameGT           *string  `json:"lastnameGT,omitempty"`
	LastnameGTE          *string  `json:"lastnameGTE,omitempty"`
	LastnameLT           *string  `json:"lastnameLT,omitempty"`
	LastnameLTE          *string  `json:"lastnameLTE,omitempty"`
	LastnameContains     *string  `json:"lastnameContains,omitempty"`
	LastnameHasPrefix    *string  `json:"lastnameHasPrefix,omitempty"`
	LastnameHasSuffix    *string  `json:"lastnameHasSuffix,omitempty"`
	LastnameIsNil        bool     `json:"lastnameIsNil,omitempty"`
	LastnameNotNil       bool     `json:"lastnameNotNil,omitempty"`
	LastnameEqualFold    *string  `json:"lastnameEqualFold,omitempty"`
	LastnameContainsFold *string  `json:"lastnameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "todos" edge predicates.
	HasTodos     *bool             `json:"hasTodos,omitempty"`
	HasTodosWith []*TodoWhereInput `json:"hasTodosWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Firstname != nil {
		predicates = append(predicates, user.FirstnameEQ(*i.Firstname))
	}
	if i.FirstnameNEQ != nil {
		predicates = append(predicates, user.FirstnameNEQ(*i.FirstnameNEQ))
	}
	if len(i.FirstnameIn) > 0 {
		predicates = append(predicates, user.FirstnameIn(i.FirstnameIn...))
	}
	if len(i.FirstnameNotIn) > 0 {
		predicates = append(predicates, user.FirstnameNotIn(i.FirstnameNotIn...))
	}
	if i.FirstnameGT != nil {
		predicates = append(predicates, user.FirstnameGT(*i.FirstnameGT))
	}
	if i.FirstnameGTE != nil {
		predicates = append(predicates, user.FirstnameGTE(*i.FirstnameGTE))
	}
	if i.FirstnameLT != nil {
		predicates = append(predicates, user.FirstnameLT(*i.FirstnameLT))
	}
	if i.FirstnameLTE != nil {
		predicates = append(predicates, user.FirstnameLTE(*i.FirstnameLTE))
	}
	if i.FirstnameContains != nil {
		predicates = append(predicates, user.FirstnameContains(*i.FirstnameContains))
	}
	if i.FirstnameHasPrefix != nil {
		predicates = append(predicates, user.FirstnameHasPrefix(*i.FirstnameHasPrefix))
	}
	if i.FirstnameHasSuffix != nil {
		predicates = append(predicates, user.FirstnameHasSuffix(*i.FirstnameHasSuffix))
	}
	if i.FirstnameIsNil {
		predicates = append(predicates, user.FirstnameIsNil())
	}
	if i.FirstnameNotNil {
		predicates = append(predicates, user.FirstnameNotNil())
	}
	if i.FirstnameEqualFold != nil {
		predicates = append(predicates, user.FirstnameEqualFold(*i.FirstnameEqualFold))
	}
	if i.FirstnameContainsFold != nil {
		predicates = append(predicates, user.FirstnameContainsFold(*i.FirstnameContainsFold))
	}
	if i.Lastname != nil {
		predicates = append(predicates, user.LastnameEQ(*i.Lastname))
	}
	if i.LastnameNEQ != nil {
		predicates = append(predicates, user.LastnameNEQ(*i.LastnameNEQ))
	}
	if len(i.LastnameIn) > 0 {
		predicates = append(predicates, user.LastnameIn(i.LastnameIn...))
	}
	if len(i.LastnameNotIn) > 0 {
		predicates = append(predicates, user.LastnameNotIn(i.LastnameNotIn...))
	}
	if i.LastnameGT != nil {
		predicates = append(predicates, user.LastnameGT(*i.LastnameGT))
	}
	if i.LastnameGTE != nil {
		predicates = append(predicates, user.LastnameGTE(*i.LastnameGTE))
	}
	if i.LastnameLT != nil {
		predicates = append(predicates, user.LastnameLT(*i.LastnameLT))
	}
	if i.LastnameLTE != nil {
		predicates = append(predicates, user.LastnameLTE(*i.LastnameLTE))
	}
	if i.LastnameContains != nil {
		predicates = append(predicates, user.LastnameContains(*i.LastnameContains))
	}
	if i.LastnameHasPrefix != nil {
		predicates = append(predicates, user.LastnameHasPrefix(*i.LastnameHasPrefix))
	}
	if i.LastnameHasSuffix != nil {
		predicates = append(predicates, user.LastnameHasSuffix(*i.LastnameHasSuffix))
	}
	if i.LastnameIsNil {
		predicates = append(predicates, user.LastnameIsNil())
	}
	if i.LastnameNotNil {
		predicates = append(predicates, user.LastnameNotNil())
	}
	if i.LastnameEqualFold != nil {
		predicates = append(predicates, user.LastnameEqualFold(*i.LastnameEqualFold))
	}
	if i.LastnameContainsFold != nil {
		predicates = append(predicates, user.LastnameContainsFold(*i.LastnameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}

	if i.HasTodos != nil {
		p := user.HasTodos()
		if !*i.HasTodos {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTodosWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasTodosWith))
		for _, w := range i.HasTodosWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTodosWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate UserWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
