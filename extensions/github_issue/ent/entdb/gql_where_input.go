// Code generated by entc, DO NOT EDIT.

package entdb

import (
	"fmt"

	"github.com/roderm/example-plugin-system/extensions/github_issue/ent/entdb/issue"
	"github.com/roderm/example-plugin-system/extensions/github_issues/ent/entdb/predicate"
)

// IssueWhereInput represents a where input for filtering Issue queries.
type IssueWhereInput struct {
	Predicates []predicate.Issue  `json:"-"`
	Not        *IssueWhereInput   `json:"not,omitempty"`
	Or         []*IssueWhereInput `json:"or,omitempty"`
	And        []*IssueWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "is_pr" field predicates.
	IsPr    *bool `json:"isPr,omitempty"`
	IsPrNEQ *bool `json:"isPrNEQ,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IssueWhereInput) AddPredicates(predicates ...predicate.Issue) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IssueWhereInput filter on the IssueQuery builder.
func (i *IssueWhereInput) Filter(q *IssueQuery) (*IssueQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering issues.
// An error is returned if the input is empty or invalid.
func (i *IssueWhereInput) P() (predicate.Issue, error) {
	var predicates []predicate.Issue
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, issue.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Issue, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, issue.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Issue, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, issue.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, issue.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, issue.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, issue.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, issue.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, issue.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, issue.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, issue.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, issue.IDLTE(*i.IDLTE))
	}
	if i.URL != nil {
		predicates = append(predicates, issue.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, issue.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, issue.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, issue.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, issue.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, issue.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, issue.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, issue.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, issue.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, issue.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, issue.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, issue.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, issue.URLContainsFold(*i.URLContainsFold))
	}
	if i.IsPr != nil {
		predicates = append(predicates, issue.IsPrEQ(*i.IsPr))
	}
	if i.IsPrNEQ != nil {
		predicates = append(predicates, issue.IsPrNEQ(*i.IsPrNEQ))
	}
	if i.Status != nil {
		predicates = append(predicates, issue.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, issue.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, issue.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, issue.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, issue.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, issue.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, issue.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, issue.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, issue.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, issue.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, issue.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, issue.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, issue.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, issue.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, issue.StatusContainsFold(*i.StatusContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("empty predicate IssueWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return issue.And(predicates...), nil
	}
}
